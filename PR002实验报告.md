# 编译原理研讨课实验PR002实验报告

## 任务说明

### 任务要求

>1. `扩展AST的表示已支持element-wise的操作`

>2. `操作匹配：类型匹配（静态数组，类型相同），大小匹配（大小相等）`

>3. `生成合法的AST`

>4. `不破坏原有C语言代码的语义`

### 任务实现

通过修改`llvm-3-3/tool/clang/lib/Sema/SemaExpr.cpp`中的部分函数，完成操作数的检查和匹配，并限定支持C语言标准的int类型的array.

## 成员组成

    段江飞，蔡昕，资威

## 实验设计

### 设计思路

在编译的语义分析阶段，编译器需要调用`Sema::ActOnBinOp`函数对二值操作符进行分析，而`Sema::ActOnBinOp`函数会调用`Sema::BuildBinOp`函数进行二值操作的创建，在`Sema::BuildBinOp`函数中，对于固定(bulit-in)的非重载的操作类型,需要调用`Sema::CreateBuiltinBinOp`函数来创建二值操作。为了支持element-wise操作，我们需要在二元操作符是'='，'+'，'*' 且element-wise生效的时候进行操作数的检查和匹配，所以本实验需要修改函数`Sema::CheckAssignmentOperands`，`Sema::CheckAdditionOperands`，`Sema:CheckMultiplyDivideOperands`以达到实验目的。

### 具体实现

`Sema::CheckAssignmentOperands` 的添加部分：
```c

  //handle the case: unqualified array '='
  //check if this function support elementwise and RHS'type is ConstantArray
  if(this->IsElementWise && RHSType.getTypePtr()->isConstantArrayType())
  {
    const ConstantArrayType *lhs = dyn_cast<ConstantArrayType>(LHSType.getTypePtr());
    const ConstantArrayType *rhs = dyn_cast<ConstantArrayType>(RHSType.getTypePtr());
    QualType lhs_dt = lhs->getElementType().getUnqualifiedType();
    QualType rhs_dt = rhs->getElementType().getUnqualifiedType();
    //check whether LHS and RHS have same size and type and make sure type of array is int  
    if(lhs->getSize() == rhs->getSize() && lhs_dt == rhs_dt && \
        lhs_dt.getTypePtr()->isIntegerType())
    {
    // check whether LHSexpr is lvalue
      if(LHSExpr->isLValue())
      {
    //if RHSexpr is not of rvalue kind ,transfer RHSCheck to rvalue kind for  assignment and building AST
    
        if(!(RHSCheck->isRValue()))
        {
          Qualifiers tmp;
          ImplicitCastExpr *rhs_r2l = ImplicitCastExpr::Create(Context, 
            Context.getUnqualifiedArrayType(RHSType.getUnqualifiedType(), tmp),
            CK_LValueToRValue, RHSCheck, 0, VK_RValue);
          RHS = rhs_r2l;
        }
      }
      
      return RHS.get()->getType();
    }
  }
```
`Sema::CheckAdditionOperands`的添加部分：
```c
  //handle the case: unqualified array '+'
  //check if this function support elementwise and LHS's and RHS'type is ConstantArray
  if(this->IsElementWise && LHS.get()->getType().getTypePtr()->isConstantArrayType() &&
    RHS.get()->getType().getTypePtr()->isConstantArrayType())
  {
    const ConstantArrayType *lhs = dyn_cast<ConstantArrayType>(LHS.get()->getType().getTypePtr());
    const ConstantArrayType *rhs = dyn_cast<ConstantArrayType>(RHS.get()->getType().getTypePtr());
    QualType lhs_dt = lhs->getElementType().getUnqualifiedType();
    QualType rhs_dt = rhs->getElementType().getUnqualifiedType();
    //check whether LHS and RHS have same size and type and make sure type of array is int 
    if(lhs->getSize() == rhs->getSize() && lhs_dt == rhs_dt &&
      lhs_dt.getTypePtr()->isIntegerType())
    {
    //if LHS or RHS is not of rvalue kind ,transfer it to rvalue kind for further addition compution  
      if(!(LHS.get()->isRValue()))
      {
        Qualifiers tmp;
        ImplicitCastExpr *lhs_r2l = ImplicitCastExpr::Create(Context, 
          Context.getUnqualifiedArrayType(LHS.get()->getType().getUnqualifiedType(), tmp),
          CK_LValueToRValue, LHS.get(), 0, VK_RValue);
        LHS = lhs_r2l;
      }
      if(!(RHS.get()->isRValue()))
      {
        Qualifiers tmp;
        ImplicitCastExpr *rhs_r2l = ImplicitCastExpr::Create(Context, 
          Context.getUnqualifiedArrayType(RHS.get()->getType().getUnqualifiedType(), tmp),
          CK_LValueToRValue, RHS.get(), 0, VK_RValue);
        RHS = rhs_r2l;
      }
      return LHS.get()->getType();
    }
  }
```

`Sema:CheckMultiplyDivideOperands`的添加部分：
```c
  //handle the case: unqualified array '*'
  //check whether this function support elementwise and LHS's and RHS'type is ConstantArray (only for multiply)
  if(!IsDiv && !IsCompAssign && this->IsElementWise &&
    LHS.get()->getType().getTypePtr()->isConstantArrayType() &&
    RHS.get()->getType().getTypePtr()->isConstantArrayType() )
  {
    const ConstantArrayType *lhs = dyn_cast<ConstantArrayType>(LHS.get()->getType().getTypePtr());
    const ConstantArrayType *rhs = dyn_cast<ConstantArrayType>(RHS.get()->getType().getTypePtr());
    QualType lhs_dt = lhs->getElementType().getUnqualifiedType();
    QualType rhs_dt = rhs->getElementType().getUnqualifiedType();
  //check whether LHS and RHS have same size and type and make sure the type of array is int 
    if(lhs->getSize() == rhs->getSize() && lhs_dt == rhs_dt &&
      lhs_dt.getTypePtr()->isIntegerType())
    {
      //if LHS or RHS is not of rvalue kind ,transfer it to rvalue kind for further compution
      if(!(LHS.get()->isRValue()))
      {
        Qualifiers tmp;
        ImplicitCastExpr *lhs_r2l = ImplicitCastExpr::Create(Context, 
          Context.getUnqualifiedArrayType(LHS.get()->getType().getUnqualifiedType(), tmp),
          CK_LValueToRValue, LHS.get(), 0, VK_RValue);
        LHS = lhs_r2l;
      }
      if(!(RHS.get()->isRValue()))
      {
        Qualifiers tmp;
        ImplicitCastExpr *rhs_r2l = ImplicitCastExpr::Create(Context, 
          Context.getUnqualifiedArrayType(RHS.get()->getType().getUnqualifiedType(), tmp),
          CK_LValueToRValue, RHS.get(), 0, VK_RValue);
        RHS = rhs_r2l;
      }
      return LHS.get()->getType();
    }
  }
  ```
  ## 测试过程

  ## 总结

  ### 实验结果总结
    经过测试，实验结果能够满足任务书中支持C语言标准的int类型的elementwize操作，检查操作匹配以及生成合法的AST的要求，并且不会破坏原有C语言代码的语义。
  ### 分成员总结
